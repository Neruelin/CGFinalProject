Tyler McFadden
Zachary Gilliland

CAP 4720 Final Project
11 December 2019

# Goals
This project simulates, with moderate accuracy, the movements of and relationships between major bodies in the solar system. Additionally, this project aimed to simulate missions that might be carried out by NASA or other aerospace companies. In particular, the Parker Solar Probe, launched in August of 2018, served as inspiration.

# Features
Concerning the accuracy of the solar system replica: when the UI option “Actual size” is selected, all objects in the scene are scaled to relative size to their ellipsoidal orbit in space. Each body’s orbital path is calculated as a function of time, and circumnavigate the sun at scale speed when the UI option “Real time” is selected. Planets rotate around an accurately-offset polar axis at a rate very near their actual angular velocity (scaled to the option selected in the time controls folder of the UI).

A physics engine relating the gravity of all bodies within the solar system, the probe objects placed in the scene, and the distances between them was created to observe the effects of initial velocity, probe weight and launch direction on long-term flight path.

Options are available for toggling the appearance of the Sun between a naked-eye glare and an ultraviolet, brightness-adjusted image. The paths of the orbits can be toggled, and individual planets can be locked onto either by typing their name in the search field of the UI or by selecting the corresponding overlay. The overlay itself can be set to display a detailed telemetry of its respective object. The probes in the simulation draw a path that can be scaled or erased.

# Notes on Scale in THREE.js
Two concepts come into conflict in this project: the massive scale of space, and the way in which transparent (or nearly transparent) objects are rendered. Objects such as those generated by the line or disk meshes in Three.js have an infinitesimal thickness or height. When rendered above or below a much more massive mesh, these thin objects tend to clip and cause graphical errors. At smaller scales, many of these errors are alleviated, as the representation of infinitesimal can be better reconciled with objects of similar size, relatively speaking.

# Notes on Gravitational Physics Engine
Our physics engine seeks to replicate the influence of the celestial bodies of our solar system on relatively small bodies such as probes and satellites. To achieve this we gathered accurate to life data from many sources, ( primarily NASA data sheets ), on properties such as mass, distance, orbital period, and orbit dimensions which were then used to simulate the motion of the solar system’s largest bodies in respect to time. With the ability to calculate the positions of each object and its mass at any given time, we calculate the gravitational acceleration vector from each physics enabled object in the direction of the body acting upon it. Using these gravitational force vectors, we calculate a net gravitational force on each physics enabled object. Using kinematic equations and frame delta time we then find the change in velocity as well as the displacement per frame. This allows us to mimic realistic movement of physics enabled objects in our simulation.

# Notes on the Data Structures Used
Other than typical Arrays and HashMaps we used custom data structures to define the specifications of all objects rendered in the simulation scene through the use of a common shape rendering pipeline. The specification includes all astrological data, ( radius, mass, tilt, day length, perihelion, aphelion, orbital inclination, orbital period, orbital eccentricity), as well as rendering information, ( shape type, widthSegments, heightSegments, texture paths, position, orbital line color). These specifications were categorized in three sections: Orbits, SpaceObjects, PhysicsObjects.

The following links to a Github-hosted deployment of the project
https://neruelin.github.io/CGFinalProject/

The following are instructions for running the project locally:

### To install dependencies:

    * Install Node.js from https://nodejs.org/en/ 
    - Ensure npm is added to PATH 
    - Run `npm install --production`

### To start Server:

    * Run `npm start`
